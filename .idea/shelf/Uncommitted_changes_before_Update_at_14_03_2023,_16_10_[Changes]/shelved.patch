Index: src/main/java/dk/dtu/compute/se/pisd/roborally/controller/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n *  This file is part of the initial project provided for the\n *  course \"Project in Software Development (02362)\" held at\n *  DTU Compute at the Technical University of Denmark.\n *\n *  Copyright (C) 2019, 2020: Ekkart Kindler, ekki@dtu.dk\n *\n *  This software is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; version 2 of the License.\n *\n *  This project is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this project; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\npackage dk.dtu.compute.se.pisd.roborally.controller;\n\nimport dk.dtu.compute.se.pisd.roborally.model.*;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * ...\n *\n * @author Ekkart Kindler, ekki@dtu.dk\n *\n */\npublic class GameController {\n\n    final public Board board;\n\n    public GameController(@NotNull Board board) {\n        this.board = board;\n    }\n\n    /**\n     * This is just some dummy controller operation to make a simple move to see something\n     * happening on the board. This method should eventually be deleted!\n     *\n     * @param space the space to which the current player should move\n     */\n\n    public void moveCurrentPlayerToSpace(@NotNull Space space)  {\n\n        // TODO Assignment V1: method should be implemented by the students:\n        //   - the current player should be moved to the given space\n        //     (if it is free()\n        //   - and the current player should be set to the player\n        //     following the current player\n        //   - the counter of moves in the game should be increased by one\n        //     if and when the player is moved (the counter and the status line\n        //     message needs to be implemented at another place)\n        if (space.getPlayer() == null) {\n            Player currentPlayer = board.getCurrentPlayer();\n            space.setPlayer(currentPlayer);\n            board.setMoveCounter(board.getMoveCounter()+1);\n            board.getStatusMessage();\n            /**\n             * Ovenfor har brugt metoden setMoveCounter til at sætte den nuværende moveCounter til +1\n             * Og derefter hentet den opdaterede statuslinje med getStatusMessage()\n             */\n            if (board.getPlayerNumber(currentPlayer)==board.getPlayersNumber()-1){\n                currentPlayer = board.getPlayer(0);\n                board.setCurrentPlayer(currentPlayer);\n            } else {\n                Player nextCurrentPlayer = currentPlayer;\n                currentPlayer = board.getPlayer(board.getPlayerNumber(nextCurrentPlayer)+1);\n                board.setCurrentPlayer(currentPlayer);\n            }\n        }\n\n\n    }\n\n    // XXX: V2\n    public void startProgrammingPhase() {\n        board.setPhase(Phase.PROGRAMMING);\n        board.setCurrentPlayer(board.getPlayer(0));\n        board.setStep(0);\n\n        for (int i = 0; i < board.getPlayersNumber(); i++) {\n            Player player = board.getPlayer(i);\n            if (player != null) {\n                for (int j = 0; j < Player.NO_REGISTERS; j++) {\n                    CommandCardField field = player.getProgramField(j);\n                    field.setCard(null);\n                    field.setVisible(true);\n                }\n                for (int j = 0; j < Player.NO_CARDS; j++) {\n                    CommandCardField field = player.getCardField(j);\n                    field.setCard(generateRandomCommandCard());\n                    field.setVisible(true);\n                }\n            }\n        }\n    }\n\n    // XXX: V2\n    private CommandCard generateRandomCommandCard() {\n        Command[] commands = Command.values();\n        int random = (int) (Math.random() * commands.length);\n        return new CommandCard(commands[random]);\n    }\n\n    // XXX: V2\n    public void finishProgrammingPhase() {\n        makeProgramFieldsInvisible();\n        makeProgramFieldsVisible(0);\n        board.setPhase(Phase.ACTIVATION);\n        board.setCurrentPlayer(board.getPlayer(0));\n        board.setStep(0);\n    }\n\n    // XXX: V2\n    private void makeProgramFieldsVisible(int register) {\n        if (register >= 0 && register < Player.NO_REGISTERS) {\n            for (int i = 0; i < board.getPlayersNumber(); i++) {\n                Player player = board.getPlayer(i);\n                CommandCardField field = player.getProgramField(register);\n                field.setVisible(true);\n            }\n        }\n    }\n\n    // XXX: V2\n    private void makeProgramFieldsInvisible() {\n        for (int i = 0; i < board.getPlayersNumber(); i++) {\n            Player player = board.getPlayer(i);\n            for (int j = 0; j < Player.NO_REGISTERS; j++) {\n                CommandCardField field = player.getProgramField(j);\n                field.setVisible(false);\n            }\n        }\n    }\n\n    // XXX: V2\n    public void executePrograms() {\n        board.setStepMode(false);\n        continuePrograms();\n    }\n\n    // XXX: V2\n    public void executeStep() {\n        board.setStepMode(true);\n        continuePrograms();\n    }\n\n    // XXX: V2\n    private void continuePrograms() {\n        do {\n            executeNextStep();\n        } while (board.getPhase() == Phase.ACTIVATION && !board.isStepMode());\n    }\n\n    // XXX: V2\n\n    /**\n     * executes a commandcard and goes to the next player. if the board is not in activation phase, then it won't work.\n     * and there is a currentplayer from the board. the step has to be between those 5 cards. if the card is null,\n     * the it won't go through. after executing command, then it will go to the next player by setting currentplayer on board,\n     * to the next player\n     */\n    private void executeNextStep() {\n        Player currentPlayer = board.getCurrentPlayer();\n        if (board.getPhase() == Phase.ACTIVATION && currentPlayer != null) {\n            int step = board.getStep();\n            if (step >= 0 && step < Player.NO_REGISTERS) {\n                CommandCard card = currentPlayer.getProgramField(step).getCard();\n                if (card != null) {\n                    Command command = card.command;\n                    if (command.isInteractive()){\n                        board.setPhase(Phase.PLAYER_INTERACTION);\n                        return;\n                    }\n                    executeCommand(currentPlayer, command);\n                }\n                int nextPlayerNumber = board.getPlayerNumber(currentPlayer) + 1;\n                if (nextPlayerNumber < board.getPlayersNumber()) {\n                    board.setCurrentPlayer(board.getPlayer(nextPlayerNumber));\n                } else {\n                    step++;\n                    if (step < Player.NO_REGISTERS) {\n                        makeProgramFieldsVisible(step);\n                        board.setStep(step);\n                        board.setCurrentPlayer(board.getPlayer(0));\n                    } else {\n                        startProgrammingPhase();\n                    }\n                }\n            } else {\n                // this should not happen\n                assert false;\n            }\n        } else {\n            // this should not happen\n            assert false;\n        }\n    }\n\n    public void executeCommandOptionAndContinue(@NotNull Command option){\n        Player currentPlayer = board.getCurrentPlayer();\n        if (board.getPhase() == Phase.PLAYER_INTERACTION && currentPlayer != null){\n            int step = board.getStep();\n            if (step >= 0 && step < Player.NO_REGISTERS) {\n                CommandCard card = currentPlayer.getProgramField(step).getCard();\n                if (card != null){\n                    Command command = card.command;\n                    executeCommand(currentPlayer, option);\n                    if (command.isInteractive()){\n                        board.setPhase(Phase.ACTIVATION);\n                        //return;\n                    }\n\n                    int nextPlayerNumber = board.getPlayerNumber(currentPlayer) + 1;\n                    if (nextPlayerNumber < board.getPlayersNumber()) {\n                        board.setCurrentPlayer(board.getPlayer(nextPlayerNumber));\n                    } else {\n                        step++;\n                        if (step < Player.NO_REGISTERS) {\n                            makeProgramFieldsVisible(step);\n                            board.setStep(step);\n                            board.setCurrentPlayer(board.getPlayer(0));\n                        } else {\n                            startProgrammingPhase();\n                        }\n                    }\n                } else {\n                    // this should not happen\n                    assert false;\n                }\n            } else {\n                // this should not happen\n                assert false;\n            }\n        }\n    }\n\n\n\n    // XXX: V2\n    private void executeCommand(@NotNull Player player, Command command) {\n        if (player != null && player.board == board && command != null) {\n            // XXX This is a very simplistic way of dealing with some basic cards and\n            //     their execution. This should eventually be done in a more elegant way\n            //     (this concerns the way cards are modelled as well as the way they are executed).\n\n            switch (command) {\n                case FORWARD:\n                    this.moveForward(player);\n                    break;\n                case RIGHT:\n                    this.turnRight(player);\n                    break;\n                case LEFT:\n                    this.turnLeft(player);\n                    break;\n                case FAST_FORWARD:\n                    this.fastForward(player);\n                    break;\n                default:\n                    // DO NOTHING (for now)\n            }\n        }\n    }\n\n    // TODO Assignment V2\n\n    /**\n     *\n     * Moves the current players robot one space i the robots current direction\n     * @param player The player which Robot is getting moved one space in the current direction\n     */\n    public void moveForward(@NotNull Player player) {\n        Space space = player.getSpace();\n        if (space != null){\n            Heading heading = player.getHeading();\n            Space space1 = board.getNeighbour(space, heading);\n            if(space1 != null && space1.getPlayer()== null) {\n                player.setSpace(space1);\n            }\n        }\n\n\n    }\n\n    // TODO Assignment V2\n\n    /**\n     * s224567:\n     * The method moves the current robot 3 spaces forward in the robots current direction.\n     * Before moving the robot the method checks if every space is free.\n     * @param player\n     */\n    public void fastForward(@NotNull Player player) {\n        this.moveForward(player);\n        this.moveForward(player);\n        this.moveForward(player);\n        // Space space = player.getSpace();\n        //Heading heading = player.getHeading();\n        //Space space1 = board.getNeighbour(space,heading);\n        //Space space2 = board.getNeighbour(space1,heading);\n        //Space space3 = board.getNeighbour(space2,heading);\n        //if (space != null && space1 != null && space2!= null && space3 != null){\n          //  player.setSpace(space3);\n        // }\n\n    }\n\n    // TODO Assignment V2\n\n    /**\n     * s224576\n     * The robots direction turns to the right\n     * @param player is the current players robot\n     */\n    public void turnRight(@NotNull Player player) {\n        Heading heading = player.getHeading();\n        player.setHeading(heading.next());\n\n    }\n\n    // TODO Assignment V2\n    /**\n     * s224576\n     * The robots direction turns to the left\n     * @param player is the current players robot\n     */\n    public void turnLeft(@NotNull Player player) {\n        Heading heading = player.getHeading();\n        player.setHeading(heading.prev());\n\n\n    }\n\n    public boolean moveCards(@NotNull CommandCardField source, @NotNull CommandCardField target) {\n        CommandCard sourceCard = source.getCard();\n        CommandCard targetCard = target.getCard();\n        if (sourceCard != null && targetCard == null) {\n            target.setCard(sourceCard);\n            source.setCard(null);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * A method called when no corresponding controller operation is implemented yet. This\n     * should eventually be removed.\n     */\n    public void notImplemented() {\n        // XXX just for now to indicate that the actual method is not yet implemented\n        assert false;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/dk/dtu/compute/se/pisd/roborally/controller/GameController.java b/src/main/java/dk/dtu/compute/se/pisd/roborally/controller/GameController.java
--- a/src/main/java/dk/dtu/compute/se/pisd/roborally/controller/GameController.java	(revision 02bd5cd8101c0b09c080b2d834f95ab994679ec1)
+++ b/src/main/java/dk/dtu/compute/se/pisd/roborally/controller/GameController.java	(date 1677597442256)
@@ -293,7 +293,6 @@
     /**
      * s224567:
      * The method moves the current robot 3 spaces forward in the robots current direction.
-     * Before moving the robot the method checks if every space is free.
      * @param player
      */
     public void fastForward(@NotNull Player player) {
